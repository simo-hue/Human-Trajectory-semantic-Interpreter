import argparse
import datetime
import re
import json
import pandas as pd
import random
import pickle
import openai

from densmapClass import *
import recommend as rcmd
from topk_lossy_count import *
from helper.utils import llama_generate, gpt_generate, mem_retrieval, act_loc
from helper.prompt import person_info_prompt, next_motivation_prompt
from helper.fitting import gen_time_duration_overall, gen_time_duration_cate, gen_time_duration_bestfit
from mem_module import MemoryModule
from scipy.stats import lognorm

def validate_date(date_str: str):
    # Regular expression for validating date format dd-mm-yyyy
    if not re.match(r'^\d{2}-\d{2}-\d{4}$', date_str):
        raise argparse.ArgumentTypeError("Invalid date format. Expected dd-mm-yyyy.")
    return date_str

def valid_time(time_str: str):
    try:
        datetime.datetime.strptime(time_str, '%H:%M')
        return True
    except ValueError:
        return False

def get_weekday(date_str: str):
    # Parse the date string into a datetime object
    date_obj = datetime.datetime.strptime(date_str, '%d-%m-%Y')
    # Get the weekday name
    weekday = date_obj.strftime('%A')
    return weekday

def check_routine_finished(time: str):
    return time == "23:59"

def time_exceed(t1: str, t2: str):
    '''Return if t2 < t1'''
    format = '%H:%M'
    time1_obj = datetime.datetime.strptime(t1, format).time()
    time2_obj = datetime.datetime.strptime(t2, format).time()

    return time1_obj > time2_obj

def time_update(curr_time: str, min: int):
    '''Return the updated time after add a time duration to the given time'''
    format = '%H:%M'
    time_obj = datetime.datetime.strptime(curr_time, format)
    new_time = time_obj + datetime.timedelta(minutes=min)
    return new_time.strftime(format)

def gen_end_time(gen_type, start_time, curr_time, distribution=None):
    '''Generate random end time for the given time duration generation method'''

    if gen_type == 'td_all':
        if distribution == None:
            print('Failed to generate random duration based on overall distribution...')
        else:
            duration = gen_time_duration_overall(distribution)

            # return the updated end time by start time + random duration generated 
            # using <<overall distribution>>
            return time_update(start_time, duration)

    elif gen_type == 'td_cate':
        if distribution == None:
            print('Failed to generate random duration based on cate distribution...')
        else:
            duration = gen_time_duration_cate(distribution)

            # return the updated end time by start time + random duration generated 
            # using <<cate based distribution>>
            return time_update(start_time, duration)
    elif gen_type == 'td_bestfit':
        if distribution == None:
            print('Failed to generate random duration based on best fit distribution...')
        else:
            duration = gen_time_duration_bestfit(distribution)

            # return the updated end time by start time + random duration generated 
            # using <<cate based best fit distribution>>
            return time_update(start_time, duration)

    # return the time generated by llm directly
    return curr_time


def valid_mot(data):
    return isinstance(data, list) and len(data) == 3 and isinstance(data[0], str) and isinstance(data[1], str)\
        and isinstance(data[2], list) and len(data[2]) == 2 and all(isinstance(item, str) for item in data[2])

def gen_next_motivation(llm: str, context: str, pre_mot, mem, date: str, weekday: str, time: str):
    msg = next_motivation_prompt(pre_mot, mem, date, weekday, time)

    while True:
        try:
            if llm == 'llama':
                res = llama_generate(context, msg)
            else:
                res = gpt_generate(context, msg, 256)

            parsed_json = json.loads(res)
            if valid_mot(parsed_json):
                break
            else:
                if (valid_mot(parsed_json[0])):
                    parsed_json = parsed_json[0]
                    print("Invalid Format received, fixed...")
                    break
                else:
                    print("Invalid Format received, retrying...")

        except json.JSONDecodeError:
            print("Invalid JSON received, retrying...")
        except openai.OpenAIError:
            print(f"Error GPT no reponse, retrying...")
            
    return parsed_json

parser = argparse.ArgumentParser(description='genMotivation')
parser.add_argument('-d', '--date', type=validate_date, help="Date in the format dd-mm-yyyy")
parser.add_argument('-n', '--num_of_days', type=int, default=1, help="Number of days to simulate")
parser.add_argument('--location', choices=['Sydney', 'Tokyo'], default='Tokyo', 
    help="Choose location: either 'Sydney' or 'Tokyo'", type=str)
parser.add_argument('-m', "--model", choices=['physical', 'physical_mix', 'llm'], default='physical_mix',
    help="Specify the model type to use: 'physical', 'physical_mix' or 'llm'", type=str)
parser.add_argument('-l', "--llm", choices=['llama', 'gpt'], default='gpt',
    help="Specify the llm type to use: llama or gpt", type=str)
parser.add_argument('-t', "--time_method", choices=['llm', 'td_all', 'td_cate', 'td_bestfit'], default='llm',
    help="Specify the time duration generation method to use: llm, td_all (time duration generated based on overall distribution) or \
td_cate (time duration generated based on the distribution of each locat category)", type=str)

args = parser.parse_args()

if __name__ == '__main__':
    # Load mem files into memory
    memory_module = MemoryModule()
    memory_module.load_memory_from_file()
    topk_counter = load_topk()
    densmap = rcmd.read_densmaps()

    print("Day count {}".format(memory_module.day_counters))

    f1 = open("res/personas.json")
    p = json.load(f1)
    date = args.date
    if (not date):
        date = datetime.datetime.today().strftime("%d-%m-%Y")

    weekday = get_weekday(date)

    f2 = open("res/activities.json")
    act = json.load(f2)

    # Factors for time duration generation for Tokyo
    if args.time_method == 'td_all':
        duration_data = pd.read_csv("data/TKY/duration_full_1min.csv")
        time_duration = duration_data['duration_minutes']
        time_fit = lognorm.fit(time_duration, floc=0)
    elif args.time_method == 'td_cate':
        with open('data/TKY/duration_cate_kde_1min.pkl', 'rb') as kde:
            time_fit = pickle.load(kde)
    elif args.time_method == 'td_bestfit':
        with open('data/TKY/duration_cate_bestfit_1min.pkl', 'rb') as kde:
            time_fit = pickle.load(kde)
    else:
        time_fit = None

    # Per day simulation
    for num in range(args.num_of_days):
        mem_res = {}

        # Per person simulation
        for i in range(len(p)):
            cur_routine = []
            time = "0:00"

            # Retrieve memory
            mem = mem_retrieval(memory_module, i, date, weekday)
            
            if mem == '':
                mem = 'No historical data available.'

            # Prepare prompt
            context = person_info_prompt(args.location, p[i]["name"], p[i]["age"], p[i]["gender"], p[i]["occupation"], p[i]["personality"]["ext"], p[i]["personality"]["agr"], p[i]["personality"]["con"], p[i]["personality"]["neu"], p[i]["personality"]["ope"])
            context += """Your daily activities, their frequencies and possible happening locations is given in your daily activity dictionary. \
Each activity in your daily activity dictionary is given in the format 'activity: [frequency, location list]' as following:  
{}.

Important:
1. In the potential location list of each activities, locations that are at the front of the list are more preferred than locations after them.
2. Person that are more open to experience (openness to experience score > 12) tend to select location more randomly
""".format(act[i])
            
            print("=== Date {} Person {} ===\n".format(date, i))

            # This is the loop that generate one day routine activity by activity (for one person)
            while (not check_routine_finished(time)):
                print("=== Person {}, now is {} ===".format(i, time))

                # Activity Generateion
                while True:
                    res = gen_next_motivation(args.llm, context, cur_routine, mem, date, weekday, time) # Return ["sleep", "Home", ["0:00", "7:29"]]
                    if (res[0] not in act_loc) or (res[1] not in act_loc[res[0]]) or not valid_time(res[2][1]):
                        if res[0] == "social event" and res[1] in act_loc['leisure activities'] and valid_time(res[2][1]):
                            res[0] = 'leisure activities'
                            break
                        else:
                            print("\n~~~~~ Rebuilding ~~~~~\n")
                            continue
                    else:
                        break

                # Get time duration distribution factor based on time_method
                if args.time_method == 'td_cate' and res[1] != 'Workplace':
                    time_statistic = time_fit[res[1]]
                elif args.time_method == 'td_bestfit':
                    time_statistic = time_fit.get(res[1], None)
                else:
                    time_statistic = time_fit

                # Destination Selection
                if (res[1] != 'Home' and res[1] != 'Workplace' and not (res[0] == 'education' and p[i]["occupation"] == 'student')):
                    # Check current location
                    if len(cur_routine) == 0:
                        user_loc = p[i]['home']
                    else:
                        user_loc = cur_routine[-1][-1]
                    
                    if args.model == 'physical':
                        name, coord = rcmd.recommend(user_loc, res, densmap,  i, topk_counter, model='gravity')
                        
                        # Check for time duration genertaion method
                        res[2][1] = gen_end_time(args.time_method, res[2][0], res[2][1], time_statistic)

                    elif args.model == 'physical_mix':
                        name, coord = rcmd.recommend(user_loc, res, densmap, i, topk_counter, model='mix')
                        
                        # Check for time duration genertaion method
                        res[2][1] = gen_end_time(args.time_method, res[2][0], res[2][1], time_statistic)

                    else:
                        recommandation = memory_module.generate_recommendation(str(i), res)

                        if (args.location == 'Tokyo'):
                            name, coord, min = memory_module.generate_choice(args.location, user_loc, res, recommandation, "POI_data/{}_ca_poi.csv".format(res[1])) # [id, coord, time (int)]
                        else:
                            name, coord, min = memory_module.generate_choice(args.location, user_loc, res, recommandation, 'data/SYD/around_unsw.csv') # [name, coord, time (int)]

                        res[2][1] = time_update(res[2][1], min)
                    
                    # Update res to ["sleep", "Hotel", ["0:00", "7:29"], name, coord] format
                    res.append(name)
                    res.append(coord)

                else:
                    res.append(res[1]) # name of the dest

                    # Coord of dest
                    if res[1] == 'Home':
                        res.append(p[i]['home'])

                        if (res[0] == 'leisure activities'):
                            res[2][1] = gen_end_time(args.time_method, res[2][0], res[2][1], time_statistic)

                    elif res[1] == 'Workplace':
                        res.append(p[i]['work'])
                    else:
                        res.append(p[i]['school'])

                        res[2][1] = gen_end_time(args.time_method, res[2][0], res[2][1], time_statistic)

                res[2][1] = time_update(res[2][1], random.randint(0, 9))

                # Error handling
                if len(cur_routine) >= 1 and time_exceed(cur_routine[-1][2][1], res[2][0]):
                    # Check if starting time of current activity < end time of previous activity
                    res[2][0] = cur_routine[-1][2][1]
                
                if time_exceed(res[2][0], res[2][1]):
                    # Check if llm generates activity that ends tomorrow
                    res[2][1] = "23:59"

                # Updating & storing data
                time = res[2][1]

                print(res)
                
                cur_routine.append(res) # Storing ["sleep", "Home", ["0:00", "7:29"], name, coord]

            with open("res/routine_{}_{}.json".format(date, i),'w') as f:
                json.dump(cur_routine, f)
            
            mem_res[str(i)] = { date: cur_routine }

        # Per day storing into memory
        memory_module.store_daily_activities(mem_res)

        _count = 0
        for persona_id, dates in mem_res.items():
            _count += 1
            for date in dates.keys():
                print("=== Day Summary {} ===".format(_count))
                memory_module.summarize_day(persona_id, date)
                # Checking if 7 days have passed to generate a weekly summary
                if memory_module.day_counters[persona_id] % 7 == 0:
                    print("=== Month Summary ===")
                    memory_module.summarize_week(persona_id, date)
                    memory_module.summarize_month(persona_id, date)
        
        print("=== Saving up topk ===")
        update_topk(topk_counter, mem_res)

        date_obj = datetime.datetime.strptime(date, '%d-%m-%Y')
        date = (date_obj + datetime.timedelta(days=1)).strftime("%d-%m-%Y")
        weekday = get_weekday(date)

    # Store the memory into files
    print("=== storing mem ===")
    memory_module.store_memory_to_file()

    print("=== storing topk ===")
    save_topk(topk_counter)
